# 開発手法詳細ガイド

**移動元**: CLAUDE.md  
**移動日**: 2025-08-03  
**移動理由**: CLAUDE.md肥大化防止・専門情報の適切分離

## 🏆 SubAgentプール方式（ADR_013準拠）

事前定義SubAgent（13種類）による並列問題解決。詳細は以下参照：
- [ADR_013: 組織管理サイクル運用規則](../07_Decisions/ADR_013_組織管理サイクル運用規則.md)
- [SubAgent組み合わせパターン](./SubAgent組み合わせパターン.md)
- [.claude/agents/](../../.claude/agents/) - SubAgent定義ファイル群

## 🤝 Claude Code × Gemini連携（正式採用）

**詳細な実践ガイド**: [Gemini連携実践ガイド](/Doc/09_Environment/Gemini連携実践ガイド.md)を参照

### 基本方針

- **ユーザーの要求を受けたら即座に`gemini -p <質問内容>`で壁打ち**を必ず実施
- Geminiの意見を鵜呑みにせず、1意見として判断。聞き方を変えて多角的な意見を抽出
- **Claude Code内蔵のWebSearchツールは使用しない**

### 三位一体の開発原則

- **ユーザー**：プロジェクトの目的・要件・最終ゴールを定義し、最終的な意思決定を行う**意思決定者**
- **Claude**：高度な計画力・高品質な実装・リファクタリング・ファイル操作・タスク管理を担う**実行者**
- **Gemini**：深いコード理解・Web検索による最新情報へのアクセス・多角的な視点からの助言・技術的検証を行う**助言者**

### 主要な活用場面

1. **技術調査**: 最新情報・エラー解決・ドキュメント検索・調査方法の確認
2. **設計検証**: アーキテクチャ・実装方針の妥当性確認
3. **コードレビュー**: 品質・保守性・パフォーマンスの評価
4. **計画立案**: タスクの実行計画レビュー・改善提案
5. **前提確認**: ユーザー、Claude自身に思い込みや勘違い、過信がないかどうか逐一確認

## 🔄 スクラム開発サイクル（正式採用）

**2025-07-09決定：縦方向スライス実装での標準開発サイクル**

**📋 詳細仕様**: [ADR_011: スクラム開発サイクル採用](/Doc/07_Decisions/ADR_011_スクラム開発サイクル採用.md)

**開発サイクル**: `計画 → 実装 → テスト → フィードバック → 修正 → テスト → ...`

**対象**: 縦方向スライス実装（ユーザー管理・プロジェクト管理・ドメイン管理・ユビキタス言語管理）

## 📈 継続的改善の実施

日次セッション記録に以下を記録し、手法の継続的改善を実施：
- **改善点**: 実施中に発見された問題点・非効率な部分
- **改善案**: 次回セッション以降での改善策
- **効果測定**: 改善策の実施効果評価
- **知見蓄積**: 成功パターン・失敗パターンの体系化

---

## 🎊 修正試行回数制限ルール（Phase B2完了成果）

**確立日**: 2025-10-27（Phase B2完了時）

### 3回修正試行ルール

**原則**:
- 3回の修正試行で解決しない場合、根本的な設計問題と判断
- 戦略的延期判断を実施（効率性より技術負債解決を優先）
- GitHub Issueに技術負債として明確に記録

**背景**:
- 同じアプローチで3回失敗する場合、アプローチ自体に問題がある可能性が高い
- 無限ループ的な試行錯誤を防止し、効率的な問題解決を促進
- 技術負債として明確に記録することで、将来の根本解決を担保

### 適用プロセス

#### Phase 1: 初回試行（1回目）
1. 問題発生・エラー確認
2. 原因分析・修正方針決定
3. 修正実施・動作確認

#### Phase 2: 再試行（2回目）
1. 1回目の失敗原因分析
2. 修正方針の見直し
3. 修正実施・動作確認

#### Phase 3: 最終試行（3回目）
1. 1-2回目の失敗原因の根本分析
2. より根本的な修正方針決定
3. 修正実施・動作確認

#### Phase 4: 戦略的延期判断（3回失敗時）
1. **根本原因分析**:
   - なぜ3回とも失敗したか
   - 設計上の問題か、実装上の問題か
   - 前提条件に問題があるか

2. **GitHub Issue記録**:
   - タイトル: [技術負債] ～（簡潔な問題記述）
   - 背景: 3回試行の経緯・各回の失敗内容
   - 根本原因: 分析結果
   - 対応方針: 戦略的延期・将来の解決方針
   - ラベル: `technical-debt`, `deferred`

3. **戦略的中断**:
   - 現在のStepでの解決を中断
   - Issue記録後、次のStepに進む

4. **将来の再実装計画**:
   - 前提条件が揃ったタイミングで再実装
   - Phase計画に明示的に組み込み

### Phase B2 Step8適用例

**問題**: E2Eテスト実装で3回修正試行→すべて失敗

**試行経緯**:
1. 1回目: セレクタ問題と想定→data-testid修正→失敗
2. 2回目: 画面遷移問題と想定→ルート修正→失敗
3. 3回目: SignalR問題と想定→待機時間調整→失敗

**根本原因分析**:
- E2Eテストシナリオと実際の画面遷移フロー不一致
- 技術負債 #53（パスワード変更機能未実装）が前提条件
- UI未実装により、E2Eテスト実装が時期尚早

**戦略的延期判断**:
- GitHub Issue #59に記録
- 前提条件: Issue #53解決（パスワード変更機能実装）
- 再実装計画: Phase B3で実装予定

### 学んだ教訓

1. **E2Eテスト設計時の事前確認**:
   - 実際のアプリケーション動作を事前確認すべき
   - 手動E2E確認を先行実施（Playwright MCP使用・5-10分）

2. **技術負債の依存関係整理**:
   - 技術負債間の依存関係を事前に整理すべき
   - 前提条件未充足のまま実装開始しない

3. **戦略的延期判断時の明確な記録**:
   - 前提条件・再実装計画を明確に記録すべき
   - Issue記録により、将来の根本解決を担保

### 期待効果

- ✅ **効率性向上**: 無限ループ的試行錯誤の防止（3回で打ち切り）
- ✅ **技術負債管理**: 明確な記録・将来の根本解決担保
- ✅ **プロセス透明性**: 戦略的延期判断の経緯・理由の明確化

---

## 🔄 Step再実行プロセス（設計判断誤り発見時）

**確立日**: 2025-11-02（Phase B-F2 Step3実施時）

### トリガー

- **ユーザー指摘**: Step実行中の設計判断・方針決定に誤りがあることを指摘された時
- **自己発見**: Step実行中に当初の設計判断が不適切であることを発見した時

### Step再実行プロセス

#### 1. 現状確認

- 現在のStage位置確認（どのStageまで完了したか）
- 誤った判断がどのStageで行われたか特定
- 既に作成された成果物の確認

#### 2. 戻り先Stage決定

**原則**: 誤った判断が行われたStageの直前に戻る

**例**: Stage2で判断誤り発見 → Stage1完了直後に戻る

#### 3. 作業のロールバック

```bash
# git restore で変更を破棄
git restore [誤ったStageで変更したファイル群]
```

**実施内容**:
- 誤ったStage以降で作成・更新したファイルを全て元に戻す
- 新規作成ファイルは削除、既存ファイルは元のバージョンに戻す

#### 4. Step組織設計書の更新

- 戻り先Stageの実行記録を「完了」状態に保持
- 誤ったStageの実行記録を削除 or 「やり直し」として記録
- 新しい正しい判断内容を記録（「結論ファースト」アプローチ）

#### 5. 再実行

- 正しい判断に基づいて、戻り先Stageの次Stageから再実行
- Step組織設計書に再実行の経緯・判断変更の理由を明記

### Phase B-F2 Step3実施例

**発生状況**:
- **Stage2判断**: integration-test Agent拡張（E2E責務追加）
- **ユーザー指摘**: Integration TestとE2E Testは異なるレイヤー、専用SubAgent新設すべき

**実施プロセス**:
1. Stage1完了直後に戻る（Stage2-7の作業を破棄）
2. git restore でStage2以降の変更を全て元に戻す
3. Step組織設計書のStage2セクションを書き直し
   - **新判断**: E2E専用SubAgent新設（推奨度 10/10点）
   - **判断根拠**: 5点（ADR_020整合性・レイヤー分離・技術スタック・Skill参照・MCP連携）
4. Stage2から再実行（正しい判断に基づく実装）

### 効果

- ✅ **設計判断の正確性向上**: 誤った判断を早期に修正、正しい方向性で実装
- ✅ **プロセス透明性確保**: やり直しの経緯・理由を明確に記録、学習機会
- ✅ **品質向上**: 誤った設計判断による技術負債の作り込みを防止

### 注意事項

- **速やかな対応**: 誤り発見後、速やかにロールバック・再実行を実施
- **記録の明確化**: なぜ判断を変更したか、Step組織設計書に明記
- **学習機会**: 誤った判断の原因分析、次回以降の改善に活用

**詳細実施例**: `Doc/08_Organization/Active/Phase_B-F2/Step03_Playwright統合基盤刷新.md` Stage2実行記録

---

## 🏗️ 技術調査アウトプット標準（アーキテクチャ図作成）

**確立日**: 2025-11-04（Phase B-F2 Step1 Agent SDK誤解訂正を受けて確立）

### 背景・確立理由

**Phase B-F2 Step1で発生した問題**:
- Agent SDKに関する重大な誤解が発生
- 誤解: Agent SDKは.NETアプリケーションに統合が必要
- 正解: Agent SDKは外部プロセスとして動作、.NET統合不要
- 原因: アーキテクチャ図不足・外部プロセス vs 統合の理解不足

### 標準プロセス

#### 1. 技術調査開始時（必須）

**アーキテクチャ図作成**:
```
調査対象技術 → アーキテクチャ図作成 → 技術的制約確認 → 判断
```

**必須内容**:
- **プロセス境界図**: 外部プロセスか統合か明示
- **相互作用図**: API呼び出し・データフロー・通信方式
- **依存関係図**: 必要な依存ライブラリ・ツール・環境

#### 2. 外部プロセス型ツールの場合（特に重要）

**明示すべき項目**:
- **プロセス境界**: どこで別プロセスとして動作するか
- **通信方式**: IPC, HTTP, JSON-RPC, stdin/stdout等
- **統合ポイント**: アプリケーションとの接続方法
- **環境要件**: 実行に必要な環境・ツール

**具体例（Agent SDK）**:
```
┌─────────────────┐
│ .NET Application │
│ (ASP.NET Core)   │
└────────┬────────┘
         │ stdin/stdout
         │ JSON-RPC
┌────────▼────────┐
│   Agent SDK     │ ← 外部プロセス（統合不要）
│ (Node.js Process)│
└─────────────────┘
```

#### 3. WebSearch並列実行による多角的検証

**情報収集プロセス**:
```bash
# 複数の情報源を並列検証
WebSearch "Agent SDK architecture" &
WebSearch "Agent SDK .NET integration" &
WebSearch "Agent SDK external process" &
wait
```

**目的**:
- 複数の視点から情報収集
- 誤った情報の影響を軽減
- 正確な理解の確立

### 期待効果

- ✅ **技術的制約の正確な理解**: プロセス境界・通信方式の明確化
- ✅ **誤判断の防止**: アーキテクチャ理解不足による誤った技術選定の防止
- ✅ **コミュニケーション改善**: ユーザーとの技術的議論の精度向上

### 適用範囲

- **必須適用**: 外部プロセス型ツール調査時（MCP Server, Agent SDK, Playwright等）
- **推奨適用**: 新規技術スタック導入時（フレームワーク・ライブラリ等）
- **任意適用**: 既知技術の再確認時

---

## ⚖️ トレードオフ判断マトリクス（品質vs効率）

**確立日**: 2025-11-04（Phase B-F2 Step2品質優先判断を受けて確立）

### 背景・確立理由

**Phase B-F2 Step2で発生した事象**:
- 当初計画: 簡潔版Skills作成（効率優先）
- ユーザー指摘: 高品質版Skills作成すべき（品質優先）
- 結果: 高品質版Skills作成により長期的価値確立

### 判断基準マトリックス

#### プロジェクトフェーズ別判断

| フェーズ | 原則 | 理由 | 例外 |
|---------|------|------|------|
| **Phase A-B（基盤確立期）** | 品質優先 | 長期的価値重視・技術基盤確立 | プロトタイプ検証時のみ効率優先可 |
| **Phase C-D（機能実装期）** | バランス | 品質維持しつつスピード重視 | 重要機能は品質優先 |
| **Phase E-F（最適化期）** | 効率優先 | スピード重視・既存基盤活用 | 新規技術導入時は品質優先 |

#### 機能重要度別判断

| 重要度 | 判断 | 対象機能例 |
|--------|------|-----------|
| **Critical** | 常に品質優先 | 認証・決済・データ整合性・セキュリティ |
| **High** | 品質優先（基盤確立期）<br>バランス（機能実装期） | コア機能・頻繁に使用される機能 |
| **Medium** | バランス | 補助機能・管理機能 |
| **Low** | 効率優先可 | 一時的な機能・プロトタイプ |

#### 成果物種類別判断

| 成果物 | 判断 | 理由 |
|--------|------|------|
| **技術基盤**（Framework, Architecture） | 品質優先 | 長期的影響大・変更コスト高 |
| **共通ライブラリ**（Skills, Commands） | 品質優先 | 再利用性重視・波及効果大 |
| **ドメインロジック**（Domain/Application層） | 品質優先 | ビジネス価値の中核 |
| **UI実装**（Web層） | バランス | ユーザー体験重視・変更容易 |
| **テスト実装** | 品質優先 | 品質保証の基盤 |
| **ドキュメント** | バランス | 実用性重視・段階的充実可 |

### 判断プロセス

#### Step 1: 自己チェック（3つの質問）

1. **長期的影響はあるか？**
   - Yes → 品質優先
   - No → 効率優先可

2. **再利用される可能性はあるか？**
   - Yes → 品質優先
   - No → 効率優先可

3. **変更コストは高いか？**
   - Yes → 品質優先
   - No → 効率優先可

#### Step 2: ユーザー確認（不明な場合）

**確認すべき状況**:
- 基盤確立期か機能実装期か不明
- 機能重要度が不明
- 品質要求レベルが不明

**確認方法**:
- AskUserQuestion tool活用
- 品質vs効率のトレードオフを明示
- 期待効果・コスト・リスクを提示

### Phase B-F2 Step2実施例

**状況**:
- 当初計画: 簡潔版Skills作成（効率優先）
- 対象: Agent Skills Phase 2展開（5個Skills）

**判断プロセス**:
1. 長期的影響: あり（Skills体系完成・Phase C以降活用）
2. 再利用可能性: あり（全Phase共通基盤）
3. 変更コスト: 高い（24ファイル作成・Skills体系全体影響）

**結論**: 品質優先（高品質版Skills作成）

**結果**:
- 総合成果物: 24ファイル（5 SKILL.md + 19補助ファイル）
- 品質: Phase 1と同等（補助ファイル3-5個/Skill）
- 期待効果: 30-40分/セッション削減・品質向上（ADR遵守率90%→98%）

### 期待効果

- ✅ **明確な判断基準**: 品質vs効率の判断を客観的に実施
- ✅ **長期的価値最大化**: 基盤確立期の品質投資により長期的ROI向上
- ✅ **柔軟な対応**: フェーズ・機能重要度に応じた適切な判断

---

## 🎯 Step開始前の目的明確化チェック

**確立日**: 2025-11-07（Phase B-F2 Step5教訓）

### 背景・確立理由

**問題**: Phase B-F2 Step5で「何のために作業するのか」が不明確だったため、Issue #51の本質を見逃し、Stage 1, 2で目的に沿わない作業を実施

**根本原因**: 組織設計ファイルに「Step目的（Why）」の記載がなかった

**解決**: step-startコマンドにセクション5.7「Step目的の明確化」を追加（必須プロセス化）

### Step目的の明確化プロセス

#### Step1（分析）の場合

**Step目的セクション構成**:
```markdown
## 🎯 Step目的（Why）

**このStepで達成すべきこと**:
- [主目的を1-2文で明記]
- [達成すべき具体的な成果]

**背景・解決すべき課題**:
- [なぜこのStepが必要か]
- [どのような課題を解決するか]

**関連Issue**: #XX
- [Issue概要の簡潔な引用]
```

#### Step2以降（実装）の場合

**Step目的セクション構成**:
```markdown
## 🎯 Step目的（Why）

**このStepで達成すべきこと**:
- [主目的を1-2文で明記]
- [達成すべき具体的な成果]

**Phase全体における位置づけ**:
- **Phase全体の課題**: [Phase_Summary.mdから引用]
- **このStepの役割**: [Phase目的達成のための技術的役割（例: Domain層実装、Infrastructure層実装等）]

**関連Issue**: #XX（該当時）
```

**理由**: Step2以降は個別課題を解決することは稀。Clean Architectureの依存関係に従ってStep分割されるため、「Phase全体における位置づけ」が適切。

### step-startコマンド実行プロセス

#### 必須プロセス（セクション5.7）

1. **Step目的の理解確認**:
   - Phase_Summary.md、関連Issue、Step作業内容から「Step目的」を理解
   - 「このStepで達成すべきこと」を1-2文で明確に説明できるか確認

2. **目的が不明確な場合の対応**:
   - AskUserQuestionツールでユーザーに以下を確認：
     * 「このStepの主目的は何ですか？」
     * 「達成すべき具体的な成果は何ですか？」
     * Step1の場合: 「どのような課題を解決しますか？」
     * Step2以降の場合: 「Phase全体における役割は何ですか？」

3. **Step目的の組織設計ファイル記録**:
   - 組織設計ファイルに「Step目的（Why）」セクションを最優先で記載
   - 関連Issueがあればリンク・概要を記載
   - Step1の場合: 背景・解決すべき課題を明記
   - Step2以降の場合: Phase全体における位置づけを明記

### 期待効果

- ✅ **目的理解の必須化**: Step開始前に「何のために作業するのか」を必ず理解
- ✅ **目的取り違え防止**: 組織設計ファイルに目的を明記することで、作業中も目的を見失わない
- ✅ **Issue本質の理解**: 関連Issueがある場合は自動的に内容を読み込み、本質を把握
- ✅ **実態に即した記載**: Step1は「課題解決」、Step2以降は「Phase全体における役割」と使い分け

### 適用実績

**Phase B-F2 Step5**（2025-11-07）:
- 失敗: Step目的不明確→Issue #51本質を見逃し→Stage 1, 2失敗
- 改善: step-startコマンド改善→Step目的セクション必須化
- 結果: 今後すべてのStepで目的を明確化してから作業開始

---

## 🔧 VS Code拡張機能メンテナンスプロセス

**確立日**: 2025-11-15

### 拡張機能自動更新の管理方針

**基本方針**:
- 自動更新は**原則有効**（最新の機能・セキュリティパッチ適用）
- リグレッション発生時のみ**一時的に**無効化
- 修正確認後、速やかに自動更新を再有効化

### リグレッション発生時の対応フロー（一時的措置）

#### Phase 1: 問題の特定（30分以内）

1. エラーメッセージ・スタックトレースの取得
2. 最近更新された拡張機能の確認
   - VSCode拡張機能ビュー → 歯車アイコン → "Extension Details"で更新日確認
3. 更新タイミングと問題発生タイミングの相関確認

#### Phase 2: アップストリーム調査（1時間以内）

1. GitHub Issuesで同一エラーメッセージを検索
2. リリースノート・変更履歴の確認
3. 既知のリグレッションバグか確認
   - ラベル "regression" の有無
   - 同時期の報告件数

#### Phase 3: 一時的回避策の実施（30分以内）

1. **バージョンダウングレード**:
   ```
   VSCode拡張機能ビュー → 対象拡張機能 → 歯車アイコン
   → "Install Another Version..." → 前バージョン選択
   ```

2. **自動更新の一時無効化**:
   ```
   歯車アイコン → "Disable Auto Update for this Extension"
   ```

3. **動作確認**:
   - ローカル環境でのビルド・実行確認
   - DevContainer環境での確認（該当する場合）

4. **チーム共有**:
   - GitHub Issueで一時的措置を記録
   - **恒久的措置ではないこと**を明記

#### Phase 4: 監視とクリーンアップ（継続的）

1. **アップストリームissueの定期監視**（週次）:
   - GitHub Issuesの進捗確認
   - リリースノートのチェック

2. **修正版リリース後の検証**:
   ```
   1. リリースノートで修正確認
   2. テスト環境で新バージョン検証
   3. 問題なければ自動更新再有効化
   4. GitHub Issueクローズ
   ```

3. **自動更新の再有効化**:
   ```
   歯車アイコン → "Enable Auto Update for this Extension"
   ```

### 重要な原則

**❌ 避けるべき対応**:
- 恒久的なバージョン固定（技術的負債の蓄積）
- チーム間での設定不統一
- アップストリーム修正の監視放棄

**✅ 推奨される対応**:
- 一時的措置であることの明示
- アップストリーム修正の積極的監視
- 修正版リリース後の速やかな適用
- 対応プロセスの文書化・共有

### 外部依存問題の管理哲学

**基本認識**:
- 外部ライブラリ/拡張機能の問題は自力で根本修正不可
- フォーク・独自ビルドは保守コスト増大のリスク
- アップストリームへの貢献（issue報告・再現手順提供）が最善

**対応優先順位**:
1. **即座の業務継続**（一時的回避策）
2. **アップストリームへの貢献**（issue報告・投票）
3. **修正版の速やかな適用**（技術的負債回避）

---

## 🔌 MCP（Model Context Protocol）仕様・メンテナンス（2025-11-02確立）

**確立日**: 2025-11-02（Phase B-F2 Step3 MCPメンテナンス機能追加時）

### MCP仕様理解

#### JSON-RPC活用（ツール一覧取得）

**ツール一覧取得方法**:
```bash
# Playwright MCP
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' \
  | npx @playwright/mcp@latest \
  | jq '.result.tools[].name'
```

**目的**:
- MCPツール数の正確な確認
- ツール追加/廃止の検出
- SubAgent定義の正確性維持

**実績**:
- Phase B-F2 Step3で Playwright MCP 21ツール確認（当初25ツール想定→21ツールに修正）
- e2e-test Agent定義の完全版実装

#### Claude SubAgent仕様（ワイルドカード非対応）

**仕様**:
- SubAgent定義の`tools`セクションでワイルドカード非対応
- 全ツールを明示的に列挙する必要あり

**影響**:
- e2e-test Agent定義: 9ツール記載 → 21ツール完全版に修正
- integration-test Agent定義: 同様の対応必要

**推奨対応**:
- `tools/list`メソッドで全ツール取得
- SubAgent定義に完全版リスト記載
- 週次振り返り時にツール変更確認

### MCPメンテナンスパターン（半自動推奨）

#### 完全自動 vs 半自動の判断

| 方式 | メリット | デメリット | 推奨 |
|------|---------|-----------|------|
| **完全自動** | 運用負荷ゼロ | 破壊的変更リスク・意図しない変更 | ❌ 非推奨 |
| **半自動** | 安全性確保・意図的更新 | 5-10分/週の運用負荷 | ✅ 推奨 |
| **手動** | 完全なコントロール | 見逃しリスク・運用負荷大 | ❌ 非推奨 |

**半自動方式の詳細**: `.claude/commands/weekly-retrospective.md` - Section 11（MCP更新確認）

#### 週次メンテナンスフロー

**実施タイミング**: 週次振り返り時（weekly-retrospective Command実行時）

**手順**:
1. **バージョン確認**:
   ```bash
   # Playwright MCP
   npx @playwright/mcp@latest --version
   npm view @playwright/mcp version

   # Serena MCP
   gh api repos/oraios/serena/releases/latest
   ```

2. **ツール変更検出**:
   ```bash
   # Playwright MCP tools/list実行
   echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' \
     | npx @playwright/mcp@latest \
     | jq '.result.tools[].name'
   ```

3. **変更レポート作成**:
   - 新規バージョンの有無
   - ツール追加/廃止/非推奨の検出
   - 影響範囲の評価（SubAgent定義への影響）

4. **SubAgent定義更新判断**:
   - ユーザーにレポート提示
   - 更新が必要な場合: 手動編集実施
   - 更新不要の場合: スキップ

**期待運用コスト**: 5-10分/週

### ADR_024参照

**MCPメンテナンス手順の完全版**: `Doc/07_Decisions/ADR_024_Playwright専用SubAgent新設決定.md`

**内容**:
- 5段階手順（バージョン確認・リリースノート確認・ツール変更検出・SubAgent定義更新判断・動作検証）
- 週次振り返り連携方法
- トラブルシューティング（ツール廃止時・新規ツール追加時）

**参照**: `.serena/memories/tech_stack_and_conventions.md` - MCP仕様・メンテナンス

---

**最終更新**: 2025-11-18（Serenaメモリスリム化実施・詳細内容移行完了）