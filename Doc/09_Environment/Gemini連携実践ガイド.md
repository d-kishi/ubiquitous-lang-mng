# Gemini連携実践ガイド

## 🎯 三位一体の開発原則

- **ユーザー**：プロジェクトの目的・要件・最終ゴールを定義し、最終的な意思決定を行う**意思決定者**
- **Claude**：高度な計画力・高品質な実装・リファクタリング・ファイル操作・タスク管理を担う**実行者**
- **Gemini**：深いコード理解・Web検索による最新情報へのアクセス・多角的な視点からの助言・技術的検証を行う**助言者**

## 🚀 実践ガイド

### 基本方針
- **ユーザーの要求を受けたら即座に`gemini -p <質問内容>`で壁打ち**を必ず実施
- Geminiの意見を鵜呑みにせず、1意見として判断。聞き方を変えて多角的な意見を抽出
- **Claude Code内蔵のWebSearchツールは使用しない**
- **o3 MCPツール使用禁止**: 現在o3 MCPは登録済みだが有効化されていないため使用不可
  - `mcp__o3-low__o3-search`、`mcp__o3__o3-search`、`mcp__o3-high__o3-search`は使用しない
  - 将来的に有効化予定だが、現時点では金銭的事情により無効
  - Web検索・技術調査は**Gemini**を活用する

## 📋 各層での専門的質問例

### 🔍 Domain層分析時
- "F#でのDDD Value Object実装のベストプラクティス"
- "F#のResult型エラーハンドリングの最新パターン"
- "F#での判別共用体を活用したドメインモデリング手法"

### 🔍 Infrastructure層分析時
- "Entity Framework Core .NET 8での最新設定パターン"
- "PostgreSQLとEF Coreのパフォーマンス最適化手法"
- "F#エンティティとEF Coreの統合パターン"

### 🔍 Application層分析時
- "Clean ArchitectureでのF#アプリケーションサービス実装"
- "F#のuse caseとC#のcontroller連携パターン"
- "F#でのコマンド・クエリ分離実装手法"

### 🔍 Contracts層分析時
- "F#の判別共用体をC#からアクセスする最新手法"
- "F#のOption型・Result型のC#変換パターン"
- "マルチ言語プロジェクトでの型変換自動化手法"

### 🔍 Architecture統合時
- "マルチ言語Clean Architectureプロジェクト構成ベストプラクティス"
- "F#とC#混在プロジェクトでのビルド順序とエラー対処"
- "Clean Architectureでの依存性注入設定パターン"

## 🔄 多角的質問による深堀りパターン

```
初回質問 → 基本的な実装パターン確認
追加質問1 → 「この手法での具体的なエラー対処法は？」
追加質問2 → 「パフォーマンスやメンテナンス性での注意点は？」
追加質問3 → 「.NET 8 + F# 9.0での最新の改善点は？」
統合確認 → 「これらを統合した場合の潜在的な問題は？」
```

## 🎯 主要な活用場面

1. **技術調査**: 最新情報・エラー解決・ドキュメント検索・調査方法の確認
2. **設計検証**: アーキテクチャ・実装方針の妥当性確認
3. **コードレビュー**: 品質・保守性・パフォーマンスの評価
4. **計画立案**: タスクの実行計画レビュー・改善提案
5. **前提確認**: ユーザー、Claude自身に思い込みや勘違い、過信がないかどうか逐一確認

## 📊 統合判断時の具体的基準と実行手順

### Architecture統合Claudeでの最終判断プロセス

#### 📋 統合判断の具体的基準
```
1. **技術的一貫性チェック**
   ✅ 各層の提案が同じ技術スタック・パターンに基づいているか
   ✅ F#↔C#境界での型変換方式が統一されているか
   ✅ エラーハンドリングパターンが全層で一貫しているか

2. **アーキテクチャ整合性チェック**
   ✅ Clean Architectureの依存性の方向が正しいか
   ✅ 各層の責任範囲が適切に分離されているか
   ✅ ドメインルールがインフラに依存していないか

3. **実装可能性チェック**
   ✅ 各層の提案を統合してビルドが成功するか
   ✅ 複雑すぎて実装・保守が困難ではないか
   ✅ 既存コードとの競合・矛盾がないか

4. **品質・保守性チェック**
   ✅ 後続開発者が理解・拡張しやすいパターンか
   ✅ テスタビリティが確保されているか
   ✅ パフォーマンスへの悪影響がないか
```

#### 📋 最終判断の実行手順
```
Phase A: 各層提案の収集・整理
├── Domain層Claudeの分析結果まとめ
├── Infrastructure層Claudeの分析結果まとめ  
├── Application層Claudeの分析結果まとめ
├── Contracts層Claudeの分析結果まとめ
└── 矛盾点・競合点の洗い出し

Phase B: 統合可能性の技術検証
├── `gemini -p "各層提案を統合した場合の技術的リスク評価"`
├── `gemini -p "提案された技術パターンの実装複雑度評価"`
└── 実装優先順位の決定

Phase C: 最終方針の決定・計画策定
├── 採用技術パターンの最終決定
├── 実装手順の具体化（Phase 1→2→3の詳細計画）
├── 品質確認ポイントの設定
└── 次回セッションでの具体的作業項目リスト作成
```

## 🎯 開発哲学・品質基準

- **一貫性最優先**: 複数の技術選択肢がある場合、プロジェクト全体の一貫性を最重視
- **既存設計との整合性**: 新機能は既存のアーキテクチャ・パターンに準拠
- **最終判断の明確化**: 外部助言（Gemini等）は参考とし、最終的な技術判断は一貫した基準で実施
- **保守性重視**: 後続開発者が理解しやすい、予測可能な実装パターンを維持
- **設計思想の継承**: 既存コードから新機能の実装方針が推測できる統一されたパターンを維持

## ⚠️ 実装フェーズでの重要な前提・制約

### 🎯 目的の明確化
- 動作するソフトウェアの段階的実装
- ビルド成功維持・品質確保・機能完成の両立
- Phase毎の価値提供・技術検証・ユーザビリティ確保

### ⚠️ 避けるべきパターン
- 場当たり的修正（症状対処ではなく原因解決）
- 過度な最適化（Phase完了を阻害する複雑化）
- 機能削除による回避（本質的解決ではない）
- スコープクリープ（Phase境界を超えた実装）

### ✅ 成功パターン
- 段階的実装（最小動作版→基本機能→拡張機能）
- 戦略的思考（問題の本質を見極めて方針決定）
- 品質管理（ビルド成功・テスト・コードレビュー）
- 根本原因解決（アーキテクチャ整合性・設計思想継承）

---

**作成日**: 2025-07-16  
**更新履歴**: 2025-07-16 CLAUDE.mdから分離・独立ファイル化